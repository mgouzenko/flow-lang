channel<int> chan_at(list<channel<int>> l, int n) {
	int i;
	list<channel<int>> cur = l;
	for(i = 0; i < n; i = i + 1) {
		cur = ^cur;
	}
	return @cur;

	if((i - 1) != n) {
		print_string("Something is very wrong...\n");
	}
}

proc comparator (in int a_in, in int b_in, out int a_out, out int b_out, bool ascending) {
	while(a_in && b_in) {
		int larger;
		int smaller;

		int a = @a_in;
		int b = @b_in;
		
		if (a < b) {
			smaller = a;
			larger = b;
		} else {
			smaller = b;
			larger = a;
		}

		if(ascending) {
			smaller -> a_out;
			larger -> b_out;
		} else {
			larger -> a_out;
			smaller -> b_out;
		}
	}
	poison a_out;
	poison b_out;
}

void bitonic_comp_network (int n, bool ascending, list<channel<int>> input_chans, list<channel<int>> output_chans) {
	int i = 0;
	int j = (n / 2);

	while(i < n / 2) {

		//print_string("a: "); print_int(i); println();
		//print_string("b: "); print_int(j); println();
		//println();
		//println();
		comparator(chan_at(input_chans, i), chan_at(input_chans, j), 
				   chan_at(output_chans, i), chan_at(output_chans, j), ascending);

		i = i + 1;
		j = j + 1;
	}
}

void bitonic_merger (int n, bool ascending, list<channel<int>> input_chans, list<channel<int>> output_chans) {

	if(n == 2) {
		comparator(chan_at(input_chans, 0), chan_at(input_chans, 1), 
				   chan_at(output_chans, 0), chan_at(output_chans, 1), ascending);
		return;
	}

	int i;

	list<channel<int>> intermediate_chans;
	for (i = 0; i < n; i = i + 1) {
		channel<int> l;
		intermediate_chans = l::intermediate_chans;
	}

	list<channel<int>> intermediate_chans_top;
	for (i = n/2 - 1; i >= 0; i = i - 1) {
		intermediate_chans_top = chan_at(intermediate_chans, i)::intermediate_chans_top;
	}
	list<channel<int>> intermediate_chans_bottom;
	for (i = n - 1; i >= n/2; i = i - 1) {
		intermediate_chans_bottom = chan_at(intermediate_chans,i)::intermediate_chans_bottom;
	}

	list<channel<int>> bitonic_outputs_top;
	for(i = n/2 - 1; i >= 0; i = i - 1) {
		bitonic_outputs_top = chan_at(output_chans, i)::bitonic_outputs_top;
	}
	list<channel<int>> bitonic_outputs_bottom;
	for (i = n - 1; i >= n/2; i = i - 1) {
		bitonic_outputs_bottom = chan_at(output_chans, i)::bitonic_outputs_bottom;
	}

	bitonic_comp_network(n, ascending, input_chans, intermediate_chans);
	bitonic_merger(n/2, ascending, intermediate_chans_top, bitonic_outputs_top);
	bitonic_merger(n/2, ascending, intermediate_chans_bottom, bitonic_outputs_bottom);
}

void bitonic_sorter (int n, bool ascending, list<channel<int>> input_chans, list<channel<int>> output_chans) {
	if(n == 2) {
		comparator(chan_at(input_chans, 0), chan_at(input_chans, 1), 
				   chan_at(output_chans, 0), chan_at(output_chans, 1), ascending);
		return;
	}

	int i;

	list<channel<int>> bitonic_inputs_top;
	for(i = n/2 - 1; i >= 0; i = i - 1) {
		bitonic_inputs_top = chan_at(input_chans,i)::bitonic_inputs_top;
	}
	list<channel<int>> bitonic_inputs_bottom;
	for (i = n - 1; i >= n/2; i = i - 1) {
		bitonic_inputs_bottom = chan_at(input_chans, i)::bitonic_inputs_bottom;
	}

	list<channel<int>> intermediate_chans;
	for (i = 0; i < n; i = i + 1) {
		channel<int> l;
		intermediate_chans = l::intermediate_chans;
	}

	list<channel<int>> intermediate_chans_top;
	for (i = n/2 - 1; i >= 0; i = i - 1) {
		intermediate_chans_top = chan_at(intermediate_chans, i)::intermediate_chans_top;
	}
	list<channel<int>> intermediate_chans_bottom;
	for (i = n - 1; i >= n/2; i = i - 1) {
		intermediate_chans_bottom = chan_at(intermediate_chans, i)::intermediate_chans_bottom;
	}

	bitonic_sorter(n/2, ascending, bitonic_inputs_top, intermediate_chans_top);
	bitonic_sorter(n/2, !ascending, bitonic_inputs_bottom, intermediate_chans_bottom);
	bitonic_merger(n, ascending, intermediate_chans, output_chans);
}

proc muxer4_1(in int a, in int b, in int c, in int d, out int out_chan) {
	while(true){
		if(a) {
			@a -> out_chan;
		} else { break; }
		if(b) {
			@b -> out_chan;
		} else { break; }
		if(c) {
			@c -> out_chan;
		} else { break; }
		if(d) {
			@d -> out_chan;
		} else { break; }
	}
	poison out_chan;
}

proc muxer1_4(out int a, out int b, out int c, out int d, in int in_chan) {
	while(true){

		if(in_chan) {
			@in_chan -> a;
		} else { break; }

		if(in_chan) {
			@in_chan -> b;
		} else { break; }

		if(in_chan) {
			@in_chan -> c;
		} else { break; }

		if(in_chan) {
			@in_chan -> d;
		} else { break; }
	}
	poison a;
	poison b;
	poison c;
	poison d;
}

proc muxer8_1(in int a, in int b, in int c, in int d, in int e, in int f, in int g, in int h, out int out_chan) {
	while(true){
		if(a) {
			@a -> out_chan;
		} else { break; }
		if(b) {
			@b -> out_chan;
		} else { break; }
		if(c) {
			@c -> out_chan;
		} else { break; }
		if(d) {
			@d -> out_chan;
		} else { break; }
		if(e) {
			@e -> out_chan;
		} else { break; }
		if(f) {
			@f -> out_chan;
		} else { break; }
		if(g) {
			@g -> out_chan;
		} else { break; }
		if(h) {
			@h -> out_chan;
		} else { break; }
	}
	poison out_chan;
}

proc muxer1_8(out int a, out int b, out int c, out int d, out int e, out int f, out int g, out int h, in int in_chan) {
	while(true){
		if(in_chan) {
			@in_chan -> a;
		} else { break; }
		if(in_chan) {
			@in_chan -> b;
		} else { break; }
		if(in_chan) {
			@in_chan -> c;
		} else { break; }
		if(in_chan) {
			@in_chan -> d;
		} else { break; }
		if(in_chan) {
			@in_chan -> e;
		} else { break; }
		if(in_chan) {
			@in_chan -> f;
		} else { break; }
		if(in_chan) {
			@in_chan -> g;
		} else { break; }
		if(in_chan) {
			@in_chan -> h;
		} else { break; }
	}
	poison a;
	poison b;
	poison c;
	poison d;
	poison e;
	poison f;
	poison g;
	poison h;
}

proc printer(in int n) {
	while(n) {
		print_int(@n);
		println();
	}
}

proc num_gen(out int nums) {
	2 -> nums;
	5 -> nums;
	4 -> nums;
	7 -> nums;
	2 -> nums;
	1 -> nums;
	9 -> nums;
	3 -> nums;
	poison nums;
}

int main() {
	list<int> unsorted = [3,2,6,5];

	channel<int> a_in;
	channel<int> b_in;
	channel<int> c_in;
	channel<int> d_in;
	channel<int> e_in;
	channel<int> f_in;
	channel<int> g_in;
	channel<int> h_in;
	list<channel<int>> in_chans = [a_in, b_in, c_in, d_in, e_in, f_in, g_in, h_in];

	channel<int> a_out;
	channel<int> b_out;
	channel<int> c_out;
	channel<int> d_out;
	channel<int> e_out;
	channel<int> f_out;
	channel<int> g_out;
	channel<int> h_out;
	list<channel<int>> out_chans = [a_out, b_out, c_out, d_out, e_out, f_out, g_out, h_out];



	bitonic_sorter(8, true, in_chans, out_chans); // occasionally performs an illegal hardware instruction
	channel<int> nums;
	muxer1_8(a_in, b_in, c_in, d_in, e_in, f_in, g_in, h_in, nums);
	num_gen(nums);
	channel<int> mux_out;
	muxer8_1(a_out, b_out, c_out, d_out, e_out, f_out, g_out, h_out, mux_out);

	printer(mux_out);

}